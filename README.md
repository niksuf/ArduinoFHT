# Преобразование Хартли на платформе Arduino

## Описание проекта

Стенд на отладочной плате с микроконтроллером Atmega 328P представлен на рисунке ниже. Будем проводить исследования на частотах слышимого диапазона (1 Гц – 20 кГц). 
На борту данного микроконтроллера находится АЦП с разрешением 10 бит, которых будет достаточно для оцифровки сигналов. Для визуального отображения информации 
воспользуемся LCD дисплеем 1602, подключенным посредством шины I2C.

С некоторыми типами данных быстрое преобразование Хартли работает быстрее, чем быстрое преобразование Фурье. Сравнить скорость можно в таблице с БПФ по ссылке: 
```https://github.com/niksuf/ArduinoFFT```

Также в файле ```*.xls``` приведен анализ спектра после воздействия шума на сигнал.

![scheme_struct](https://github.com/niksuf/ArduinoFHT/blob/master/img/structural_scheme.png)

Так как с ПК посредством jack-кабеля 3.5 мм приходит слишком слабый сигнал, поставим резистивный делитель. Для того, чтобы избавиться от постоянной составляющей сигнала 
поставим конденсатор емкостью 10 нФ.

После проверки работоспособности схемы, немного переработаем ее для того, чтобы считать показания с микропроцессора и построить графики по полученным данным. Будем 
передавать данные посредством COM-порта.

Для исследования влияния шумов на собранный усилитель воспользуемся онлайн генератором шумов (https://29a.ch/noise-generator/), меняя процентное соотношение заполнения 
белого шума. Для подачи сигнала будем использовать онлайн генератор частот (https://www.szynalski.com/tone-generator/).

Значения, которые приходят в COM-порт являются сырыми оцифрованными значениями напряжения. Так как у нас АЦП разрядностью 10 бит, в порт приходят значения от 0 до 1023. 
Опорное напряжение составляет 5 В. Чтобы перевести сырые значения в напряжения, воспользуемся формулой: U<sub>вх</sub> = 5 * V / 1024.

Более подробная схема для сборки стенда:

![scheme_connection](https://github.com/niksuf/ArduinoFHT/blob/master/img/connection_scheme.png)

## Скорость работы алгоритма

Число отсчетов N | Запуск, мс | Реорганизация, мкс | Функция-окно, мкс | Линейный формат (16 бит), мкс | Линейный формат (8 бит), мкс| Логариф-мический формат, мкс
--- | --- | --- | --- | --- | --- | --- |
256 | 3.18 | 363 | 576 | 566 | 441 | 508
128 | 1.30 | 123 | 288 | 287 | 220 | 258
64 | 0.51 | 61 | 144 | 148 | 111 | 130
32 | 0.18 | 27 | 72 | 77 | 56 | 66
16 | 0.12 | 13 | 36 | 44 | 28 | 39

Примечание: Значения для линейного формата (8 бит) – приблизительные, так как могут немного варьироваться из-за директивы SCALE. Директива SCALE отвечает за 
масштабирование конечных результатов вычислений. Поскольку 8 бит – слабое разрешение, скорее всего придется масштабировать данные, чтобы максимизировать их до полного 
диапазона.

## Использование памяти

Число отсчетов N | Запуск, S/F, байт | Реорганизация, F, байт | Функция-окно, F, байт | Линейный формат (16 бит), S/F, байт | Линейный формат (8 бит), S/F, байт | Логариф-мический формат, S/F, байт
--- | --- | --- | --- | --- | --- | --- |
256 | 512/476 | 120 | 512 | 256/768 | 128/640 | 128/256
128 | 256/224 | 56 | 256 | 128/768 | 64/640 | 64/256
64 | 128/100 | 28 | 128 | 64/768 | 32/640 | 32/256
32 | 64/40 | 12 | 64 | 32/768 | 16/640 | 16/256
16 | 32/12 | 6 | 32 | 16/768 | 8/640 | 8/256

## Установка и прошивка

1. Скачать репозиторий к себе на компьютер при помощи команды: ```git clone https://github.com/niksuf/ArduinoFHT```
2. Установить библиотеки в\
```C:\Program Files (x86)\Arduino\libraries\``` (Windows x64)\
```C:\Program Files\Arduino\libraries\``` (Windows x86)
3. Подключить Ардуино к компьютеру.
4. Запустить файл прошивки (который имеет расширение ```*.ino```)
5. Настроить IDE (COM порт, модель Arduino)
6. Настроить что нужно по проекту.
7. Нажать загрузить.
8. Все готово :)

# Описание методов библиотеки FHT

Функция fht_run() – главная функция библиотеки БПХ. Ей не нужны никакие аргументы, она ничего не возвращает. В момент запуска этой функции предполагается, что нужные 
данные уже реорганизованы и находятся в SRAM-памяти. Эти данные хранятся в массиве с названием fht_input[], который содержит одно 16-битное значение – действительное. 
Окончательный вывод сохраняется в массив fht_input[], где ячейки от 0 до N/2 содержат сумму действительных и мнимых компонент, а ячейки от N/2 до N содержат разницу 
между действительными и мнимыми компонентами. Эти две части необходимо возвести в квадрат и суммировать, чтобы получить окончательную величину отсчета на определенной 
частоте. Чтобы получить из этих отсчетов полезные данные, понадобится запустить одну из трех амплитудных функций.

Функция fht_reorder() реорганизовывает входные данные, подготавливая их к обработке алгоритмом БПХ. Эта функция может не понадобиться, если реорганизация выполняется 
вручную. Функция fht_reorder() выполняется перед функцией fht_run(). Ей не нужны никакие аргументы, и она ничего не возвращает. Перед вызовом этой функции нужно 
заполнить массив fht_input[], т.к. она берет оттуда данные.

Функция fht_window() умножает входные данные при помощи функции-окна, чтобы увеличить частотное разрешение данных. Ей не нужны никакие аргументы, и она ничего не 
возвращает. Перед вызовом этой функции нужно заполнить массив fht_input[], т.к. она берет оттуда данные. Функция fht_window() запускается перед fht_run() и 
fht_reorder().

Функция fht_mag_lin8() дает амплитуду для каждого отсчета БПХ. Она суммирует квадраты действительной и мнимой частей, а затем извлекает квадратный корень, округляя 
результат до 8-битного значения. Ей не нужны никакие аргументы, и она ничего не возвращает. Она берет данные из массива fht_input[], а результат сохраняется в массив 
fht_lin_out8[]. Результат рассчитывается только для первых N/2 амплитуд, т.к. вторая половина БПХ идентична первой для всего диапазона исходных значений. Чтобы 
установить нужный масштаб, следует воспользоваться директивой SCALE (более подробно она будет описана ниже).

Функция fht_mag_lin() дает амплитуду для каждого отсчета БПХ. Она суммирует квадраты действительной и мнимой частей, затем извлекает квадратный корень. Функция 
охватывает полный 16-битный диапазон, но в любой точке этого диапазона разрешение все равно будет 8-битным. Ей не нужны никакие аргументы, и она ничего не возвращает. 
Она берет данные из массива fht_input[], а результат сохраняется в массив fht_lin_out[]. Результат рассчитывается только для первых N/2 амплитуд, т.к. вторая половина 
БПХ идентична первой для всего диапазона исходных значений.

Функция fht_mag_log() дает амплитуду для каждого отсчета БПХ. Она суммирует квадраты действительной и мнимой частей, затем извлекает квадратный корень и берет 
логарифм по основанию 2. Функция охватывает полный 16-битный диапазон, но в любой точке этого диапазона разрешение все равно будет 8-битным. Ей не нужны никакие 
аргументы, и она ничего не возвращает. Она берет данные из массива fht_input[], а результат сохраняется в массив fht_log_out[]. Результат рассчитывается только для 
первых N/2 амплитуд, т.к. вторая половина БПХ идентична первой для всего диапазона исходных значений.

Директивы:\
– FHT_N задает размер БПХ (кол-во отсчетов). Возможны варианты: 16, 32, 64, 128, 256.\
– SCALE отвечает за масштабирование функции fht_mag_lin8(), т.к. 8 бит – довольно слабое разрешение. Данная директива умножает данные на константу после вычислений.\
– LIN_OUT8, LIN_OUT, LOG_OUT включают и выключают соответствующие функции (принимают значения «0» или «1») для экономии памяти и времени за счет выключения 
неиспользуемых функций.

Методы, использованные для ускорения библиотеки:\
– во время умножения фиксированных констант на косинусы и синусы используется сложение в случаях, когда синус или косинус равен «0» или «1». Умножение 16 х 16 байт 
занимает 18 тактовых циклов, сложение 16 + 16 байт занимает 2 тактовых цикла. За счет этого уменьшается время выполнения;\
– таблицы поиска, с помощью которых рассчитываются квадратные корни амплитуд. Данная таблица сжата, из-за чего приходится проводить линейную интерполяцию для 
входных данных, однако это происходит в любом случае быстрее, чем вычислять квадратные корни амплитуд.

Частота опроса аналогового порта была поднята до 38.4 кГц, благодаря чему входной сигнал по теореме Котельникова может достигать 19.2 кГц (для правильно оцифровки). 
Для увеличения точности уменьшаем опорное напряжение, выставив EXTERNAL и подключив Aref к выходу 3.3V на плате через делитель.
